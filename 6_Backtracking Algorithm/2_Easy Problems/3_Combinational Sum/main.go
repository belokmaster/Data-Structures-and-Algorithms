package main

import (
	"fmt"
	"sort"
)

// Учитывая массив различных целых чисел arr[] и целочисленную цель, задача состоит в том,
// чтобы найти список всех уникальных комбинаций массива, где сумма выбранных элементов равна таргету.

/*
Идея состоит в том, чтобы использовать обратный поиск и рекурсивно исследовать все возможные комбинации
элементов данного массива, которые в сумме приводят к заданному целевому значению.
Если оставшаяся сумма становится меньше 0, выполните обратный поиск для изучения других возможных комбинаций.
*/

// Временная сложность: O(K * 2k), где K - средний размер допустимой комбинации и k = Целевой показатель / мин (arr),
// глубина дерева рекурсии.
// Вспомогательное пространство: O(k), учитывая рекурсивный стек и пренебрегая пространством, необходимым для хранения комбинаций.

// Функция для генерации всех комбинаций чисел, сумма которых равна target
func makeCombination(arr []int, remSum int, cur []int, res *[][]int, index int) {
	// Если сумма достигнута, добавляем комбинацию в результат
	if remSum == 0 {
		combination := make([]int, len(cur))
		copy(combination, cur)
		*res = append(*res, combination)
		return
	}

	// Если сумма стала отрицательной или вышли за границы массива, прерываем рекурсию
	if remSum < 0 || index >= len(arr) {
		return
	}

	// Добавляем текущий элемент в комбинацию
	cur = append(cur, arr[index])
	makeCombination(arr, remSum-arr[index], cur, res, index)

	// Удаляем последний элемент (backtracking)
	cur = cur[:len(cur)-1]

	// Переходим к следующему элементу
	makeCombination(arr, remSum, cur, res, index+1)
}

// Функция для поиска всех комбинаций чисел, сумма которых равна target
func combinationSum(arr []int, target int) [][]int {
	sort.Ints(arr) // Сортируем массив
	var res [][]int
	makeCombination(arr, target, []int{}, &res, 0)
	return res
}

func main() {
	arr := []int{2, 4, 3, 6, 8}
	target := 8

	res := combinationSum(arr, target)

	for _, v := range res {
		fmt.Println(v)
	}
}
