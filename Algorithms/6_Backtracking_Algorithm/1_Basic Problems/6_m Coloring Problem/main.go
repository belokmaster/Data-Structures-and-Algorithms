package main

import "fmt"

/*
Учитывая неориентированный граф и число m, задача состоит в том, чтобы раскрасить данный граф не
более чем в m цветов таким образом, чтобы ни одна из двух соседних вершин графа
не была окрашена в один и тот же цвет
*/

// Временная сложность: O(m^V). Всего существует O(m^V) комбинаций цветов
// Пространственная: O(V). Для рекурсивной функции раскраски стека графов потребуется O(V) пространства.

// Количество вершин в графе
const V = 4

// isSafe проверяет, можно ли назначить цвет c для вершины v
func isSafe(v int, graph [V][V]bool, color []int, c int) bool {
	// Проверяем все соседние вершины
	for i := 0; i < V; i++ {
		// Если есть ребро между вершинами v и i и цвет i уже совпадает с c, то назначение этого цвета недопустимо
		if graph[v][i] && color[i] == c {
			return false
		}
	}
	return true
}

// graphColoringUtil — рекурсивная функция для решения задачи раскраски графа
func graphColoringUtil(graph [V][V]bool, m int, color []int, v int) bool {
	// Базовый случай: если все вершины раскрашены, возвращаем true
	if v == V {
		return true
	}

	// Пробуем назначить вершине v различные цвета
	for c := 1; c <= m; c++ {
		// Если назначение цвета c для вершины v безопасно
		if isSafe(v, graph, color, c) {
			// Назначаем цвет для вершины
			color[v] = c

			// Рекурсивно раскрашиваем остальные вершины
			if graphColoringUtil(graph, m, color, v+1) {
				return true
			}

			// Если назначение цвета c не привело к решению, откатываем изменения
			color[v] = 0
		}
	}

	// Если для вершины v невозможно назначить ни один цвет, возвращаем false
	return false
}

// graphColoring решает задачу раскраски графа с помощью алгоритма обратного хода
func graphColoring(graph [V][V]bool, m int) bool {
	// Инициализируем массив цветов, заполняем его нулями (значение 0 означает отсутствие цвета)
	color := make([]int, V)
	for i := 0; i < V; i++ {
		color[i] = 0
	}

	// Вызываем рекурсивную функцию для первой вершины (0)
	if !graphColoringUtil(graph, m, color, 0) {
		fmt.Println("Решение не существует")
		return false
	}

	// Если раскраска найдена, выводим решение
	printSolution(color)
	return true
}

// printSolution выводит решение, т.е. раскраску графа
func printSolution(color []int) {
	fmt.Println("Решение существует: Следующие цвета назначены вершинам:")
	for i := 0; i < V; i++ {
		fmt.Printf("%d ", color[i])
	}
	fmt.Println()
}

func main() {
	// Создаем следующий граф и проверяем, возможно ли его раскрасить в 3 цвета
	// (3)---(2)
	//  |   / |
	//  |  /  |
	//  | /   |
	// (0)---(1)
	graph := [V][V]bool{
		{false, true, true, true},  // Вершина 0 соединена с вершинами 1, 2, 3
		{true, false, true, false}, // Вершина 1 соединена с вершинами 0, 2
		{true, true, false, true},  // Вершина 2 соединена с вершинами 0, 1, 3
		{true, false, true, false}, // Вершина 3 соединена с вершинами 0, 2
	}

	// Количество цветов
	m := 3

	// Вызов функции для нахождения раскраски графа
	graphColoring(graph, m)
}
