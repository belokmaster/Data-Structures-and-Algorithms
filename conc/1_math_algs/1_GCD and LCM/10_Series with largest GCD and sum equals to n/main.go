package main

import "fmt"

/*
Учитывая целое число n, выведите k увеличивающихся чисел таким образом,
чтобы сумма k чисел была равна n, а число точек пересечения k чисел было максимальным из
всех возможных рядов. Если ни один из возможных рядов не указан, выведите “-1”.

Наиболее распространенным наблюдением является то, что число узлов в ряду всегда будет делителем числа n.
Максимально возможное число узлов будет равно n/sum, где sum - это сумма 1+2+..k
*/

func printSequence(n, k int) {
	// Находим максимальный возможный НОД последовательности
	b := n / (k * (k + 1) / 2)

	// Если максимальный НОД равен 0, последовательность невозможна
	if b == 0 {
		fmt.Println(-1)
		return
	}

	// Минимальный возможный НОД — 1
	r := 1

	// Перебираем возможные значения НОД
	for x := 1; x*x <= n; x++ {
		if n%x != 0 {
			continue
		}

		// Проверяем делитель x
		if x <= b && x > r {
			r = x
		}

		// Проверяем n/x
		if n/x <= b && n/x > r {
			r = n / x
		}
	}

	// Печатаем элементы последовательности
	for i := 1; i < k; i++ {
		fmt.Print(r*i, " ")
	}

	// Вычисляем последний элемент
	res := n - (r * (k * (k - 1) / 2))
	fmt.Println(res)
}
