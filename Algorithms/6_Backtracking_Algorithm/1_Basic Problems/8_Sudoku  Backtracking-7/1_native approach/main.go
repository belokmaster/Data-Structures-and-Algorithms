package main

import (
	"fmt"
)

/*
Дано неполное судоку в виде матрицы mat[][] порядка 9*9, задача состоит в том, чтобы завершить судоку.
Решение судоку должно удовлетворять  всем следующим правилам :

Каждая из цифр  1-9 должна встречаться ровно один раз в каждой строке.
Каждая из цифр  1-9 должна встречаться ровно один раз в каждом столбце.
Каждая из цифр  1-9 должна встречаться ровно один раз в каждом из 9  3x3 подполей сетки.
*/

/*
Идея состоит в том, чтобы использовать возврат и рекурсивно генерировать все возможные конфигурации
чисел от 1 до 9 для заполнения пустых ячеек матрицы mat[][].
Для этого для каждой нераспределенной ячейки заполните ячейку числом от 1 до 9 по одному.
После заполнения нераспределенной ячейки проверьте, безопасна ли матрица .
Если безопасна, перейдите к следующей ячейке, иначе выполните возврат для других случаев.

Чтобы проверить , безопасно ли помещать значение num в ячейку mat[i][j] , пройдитесь по всем столбцам строки i ,
строкам столбца j и матрице 3*3 , содержащей ячейку (i, j) , и проверьте , есть ли у них уже значение num ,
если да, верните false , в противном случае верните true .
*/

const N = 9

// Проверяет, можно ли разместить num в mat[row][col]
func isSafe(mat *[N][N]int, row, col, num int) bool {
	// Проверка строки
	for x := 0; x < N; x++ {
		if mat[row][x] == num {
			return false
		}
	}

	// Проверка столбца
	for x := 0; x < N; x++ {
		if mat[x][col] == num {
			return false
		}
	}

	// Проверка 3x3 квадрата
	startRow, startCol := row-row%3, col-col%3
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if mat[startRow+i][startCol+j] == num {
				return false
			}
		}
	}

	return true
}

// Рекурсивная функция для решения судоку
func solveSudokuRec(mat *[N][N]int, row, col int) bool {
	// Базовый случай: дошли до конца
	if row == N-1 && col == N {
		return true
	}

	// Переход на следующую строку
	if col == N {
		row++
		col = 0
	}

	// Если ячейка уже заполнена, идем дальше
	if mat[row][col] != 0 {
		return solveSudokuRec(mat, row, col+1)
	}

	for num := 1; num <= 9; num++ {
		if isSafe(mat, row, col, num) {
			mat[row][col] = num
			if solveSudokuRec(mat, row, col+1) {
				return true
			}
			mat[row][col] = 0
		}
	}

	return false
}

func solveSudoku(mat *[N][N]int) {
	solveSudokuRec(mat, 0, 0)
}

func printSudoku(mat *[N][N]int) {
	for i := 0; i < N; i++ {
		for j := 0; j < N; j++ {
			fmt.Printf("%d ", mat[i][j])
		}
		fmt.Println()
	}
}

func main() {
	mat := [N][N]int{
		{3, 0, 6, 5, 0, 8, 4, 0, 0},
		{5, 2, 0, 0, 0, 0, 0, 0, 0},
		{0, 8, 7, 0, 0, 0, 0, 3, 1},
		{0, 0, 3, 0, 1, 0, 0, 8, 0},
		{9, 0, 0, 8, 6, 3, 0, 0, 5},
		{0, 5, 0, 0, 9, 0, 6, 0, 0},
		{1, 3, 0, 0, 0, 0, 2, 5, 0},
		{0, 0, 0, 0, 0, 0, 0, 7, 4},
		{0, 0, 5, 2, 0, 6, 3, 0, 0},
	}

	solveSudoku(&mat)
	printSudoku(&mat)
}
